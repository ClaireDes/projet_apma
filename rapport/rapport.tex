\documentclass[a4paper,11pt]{article}
% \documentstyle[11pt]{article}
\usepackage[utf8]{inputenc} % permet de mettre les accents (UTF8)
\usepackage{graphicx}
% \pagestyle{headings}

\oddsidemargin 1 cm
\evensidemargin 1 cm
\textwidth 15 cm
\topmargin 0 cm
\textheight 22.5 cm

\begin {document}

\title {Jeu √† deux joueurs √† somme nulle et √† information compl√®te \\
Application au Puissance4}

\author{Claire DESHAYES \\ Fran√ßois COMBE}
\date{\today}
\maketitle

\section*{Introduction}

Nous avons choisi de r√©aliser le projet de jeu √† somme nulle
et √† information compl√®te appliqu√© puissance 4. Nous nous sommes
donc dans un premier tempsconcentr√© sur les packages {\tt Partie}
et {\tt Puissance4}. \\ \\
Une fois le jeu fonctionnant pour deux joueurs humains nous avons
entrepris d'impl√©menter une IA capable de jouer (et surtout de bien
jouer) au Puissance4.

\section{Impl√©mentation du jeu Puissance4}

\subsection{Le package {\tt Partie}}

Ce {\tt package} ne contient qu'une proc√©dure {\tt Joue\_Partie} qui en
fonction de l'√©tat actuel du jeu va demander au joueur √† qui c'est le
tour de jouer, afficher le jeu, regarder si le joueur √† gagn√© ou si la partie
est nulle, et fonction annoncer le vainqueur ou s'appeler r√©cursivement pour
faire jouer l'adversaire. \\
Pour cela, la proc√©dure {\tt Joue\_Partie} utilise les fonctions d√©finies dans
le {\tt package Puissance4} et s'occupe de g√©rer le d√©roulement de la partie.\\
\\
Nous n'avons pas eu √† faire √©norm√©ment de choix pour cette partie. En
effet il s'agit d'un enchainement d'appels aux fonctions adapt√©es.
Le seul point que nous aurions pu √©ventuellement am√©lior√© est la distinction
entre les deux joueurs. Il √©tait peut-√™tre possible d'am√©liorer notre code
de ce point de vue afin d'√©viter les redondances mais nous avons pr√©f√©r√©
donner la priorit√© √† d'autres points.

\subsection{Le package {\tt Participant}}

Ce {\tt package} est tr√®s simple et n'a pas n√©cessit√© que l'on y passe beaucoup
de temps. La fonction {\tt Adversaire} retourne le joueur adverse du joueur
pass√© en param√®tre. Et le type {\tt Joueur} est d√©fini comme un entier
tel un {\tt enum} en language C qui peut prendre trois valeurs : Joueur1
, Joueur2 et Vide (n√©cessaire pour le package {\tt Puissance4}).
Cela apporte de la lisibilit√© au code.

\subsection{Le package {\tt Puissance4}}

C'est le {\tt package} qui a demand√© le plus travail pour cette partie.
Il contient les fonctions et les proc√©dures n√©cessaires √† {\tt Joue\_Partie}.
Une partie de Puissance4 est d√©finie par le nombre de lignes et de colonnes
du jeu ainsi que le nombre de pions √† aligner pour gagner. \\
Nous avons d√©fini le type {\tt Etat} comme un tableau √† deux dimensions de
{\tt Joueur} repr√©sentant le jeu ({\it Pour un Etat E, E(i,j) vaut Joueur1 si
le joueur 1 a jou√© sur cette case}). \\
Le type {\tt Coup} est d√©fini comme une structure contenant un entier {\tt Col}
repr√©sentant la colonne dans laquelle on joue et le {\tt Joueur J} qui indique
quel joueur √† jouer ce coup.\\
\\
La proc√©dure {\tt Initialiser} met toute les cases de l'√©tat pass√© en param√®tre
√† {\tt Vide}. \\
La fonction {\tt Jouer} applique le coup √† l'√©tat, tout deux
pass√©s en param√®tres, et retourne l'√©tat. Dans le cas o√π le coup n'est pas
possible (c'est √† dire que la colonne est pleine) la fonction retourne l'√©tat
pr√©cedent m√™me si ce cas est normalement √©vit√© en amont. \\
La fonction {\tt Est\_Gagnant} retourne le bool√©en {\tt true} si le joueur pass√©
en param√®tre √† align√© le nombre de pions n√©cessaires. La fonction parcours dans
premier temps les lignes, puis les colonnes, et enfin les diagonales. Afin
de faire un parcours des diff√©rentes diagonales possibles "intelligent" nous avons
utilis√© deux variables {\tt nb\_diags} pour le nombre de diagonales √† sur
lesquelles on peut aligner le nombre de pions n√©cessaires et {\tt c\_diags}
qui peut s'apparenter un indice des diagonales et qui est utile pour
l'algorithme de parcours des cases. En cons√©quence, si le code est peut-√™tre
difficile √† lire, il est efficace est r√©pond √† toute les configurations de jeu
possibles.\\
La fonction {\tt Est\_Nul} retourne simplement le bool√©en {\tt true} si le jeu
est plein (il n'y a plus de case vide) et que les deux joueurs n'ont pas gagn√©
(ce que l'on v√©rifie avec des appels √† la fonction {\tt Est\_Gagnant}). \\
Les proc√©dures {\tt Afficher} et {\tt Affiche\_Coup} affichent respectivement
une repr√©sentation du jeu et le dernier coup jou√© d'une fa√ßon tr√®s claire. \\
Enfin les fonctions {\tt Demande\_Coup\_Joueur} cr√©ent un {\tt Coup}, demandent
au joueur dans quelle colonne il veut jouer et retournent le coup. C'est √† ce niveau
que l'on g√®re le cas o√π on joue dans une colonne pleine. Dans ce cas on
redemande au m√™me joueur de jouer √† nouveau.\\
\\
C'est ce module qui nous a prit le plus de temps et a √©t√© le plus compliqu√©
√† mettre en place. En effet nous avions dans un premier temps prit la d√©cision
de repr√©senter un {\tt Etat} par un tableau en une dimension. Nous avons eu
ainsi beaucoup de difficult√© √† trouver un algorithme parcourant les diagonales.
Suite √† quoi nous avons modifi√© notre projet pour qu'il soit tel qui l'est
aujourd'hui.

\subsection{L'algorithme MinMax}

Dans cette partie nous avons le squelette du package Moteur_Jeu qui nous est donnÈ. Il s'agissait donc de le dÈvelopper puis de l'implÈmenter, ce que nous avons fait gr‚ce ‡ un package {\tt main1joueur}. On y instancie donc le package Puissance 4 de la mÍme faÁon que main2joueur. Ensuite on instancie le package Moteur_Jeu, pour Èviter de rÈ-Ècrire des parties de code nous avons fait le choix d'ajouter au package puissance4 les fonctions et procÈdures nÈcessaire pour l'instanciation du package Moteur_Jeu.
Enfin nous avons choisi d'instancier la partie en changeant simplement la fonction Demande_Coup_Joueur2 par Choix_Coup, pour ne pas demander au deuxiËme joueur de jouer mais laisser l'ordinateur choisir et jouer son coup.

Cependant, notre premiËre idÈe Ètant de crÈer un package moteur_jeu_puissance4qui implÈmente toutes les fonctions et procÈdures nÈcessaires ‡ l'instanciation d'un package moteur_jeu pour le puissance 4, notre changement nous a posÈ des problËmes de visibilitÈs entre les packages.
Aussi nous avons ÈtÈ obligÈ de changer la signature la fonction Eval pour quelle prenne en paramËtre le joueur moteur car il n'Ètait pas visible dans le package puissance4.

\subsection{Le package {\tt Moteur_jeu}}

Dans ce package nous devions mettre en place l'algorithme Min Max dans la fonction Choix_Coup.Pour cela nous parcourons les coups atteignable en un coup et nous Èvalons le gain de chaque coup gr‚ce ‡ la fonction Eval_Min_Max. On retourne le meilleur coup.

Dans la fonction Eval_Min_Max, nous avons choisi de parcourir en profondeur sur un entier P_Courant. Quand un Ètat terminal est atteint on renvoie le gain maximum largeur*hauteur en cas de victoire, son opposÈ en cas de dÈfaite et zÈro pour un match nul. Si l'Ètat n'est pas terminal applique par rÈcurrence la fonction Eval_Min_Max aux coups atteignables au prochain tour selon le principe Min/Max.





















\end {document}
